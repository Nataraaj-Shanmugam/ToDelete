package org.nataraaj;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

public class XMLParser {

    private static final XmlMapper xmlMapper = new XmlMapper();

    // Method to read XML from a file and convert to a JsonNode
    public static JsonNode readXmlFromFile(String filePath) throws IOException {
        return xmlMapper.readTree(new File(filePath));
    }

    // Method to read XML from a string (API response) and convert to a JsonNode
    public static JsonNode readXmlFromString(String xmlString) throws IOException {
        return xmlMapper.readTree(xmlString);
    }

    // Method to convert a JsonNode to a Map
    public static Map<String, Object> convertToMap(JsonNode node) {
        ObjectMapper jsonMapper = new ObjectMapper();
        return jsonMapper.convertValue(node, Map.class);
    }

    // Method to convert a JsonNode to a List of Maps or Strings
    public static List<Object> convertToList(JsonNode node) {
        ObjectMapper jsonMapper = new ObjectMapper();
        List<Object> list = new ArrayList<>();
        if (node.isArray()) {
            for (JsonNode arrayNode : node) {
                if (arrayNode.isObject()) {
                    list.add(jsonMapper.convertValue(arrayNode, Map.class));
                } else if (arrayNode.isTextual()) {
                    list.add(arrayNode.asText());
                } else {
                    list.add(jsonMapper.convertValue(arrayNode, Object.class));
                }
            }
        } else {
            throw new IllegalArgumentException("The node is not an array");
        }
        return list;
    }

    // Method to find a node by path and convert it to a map
    public static Map<String, Object> findNodeAndConvertToMap(JsonNode rootNode, String nodePath) {
        JsonNode currentNode = findNode(rootNode, nodePath);
        if (currentNode.isMissingNode()) {
            return Collections.emptyMap(); // Invalid path, return empty map
        }
        if (currentNode.isArray()) {
            throw new IllegalArgumentException("The specified path leads to an array node, not an object node");
        }
        return convertToMap(currentNode);
    }

    // Method to find a node by path and convert it to a list of maps or strings
    public static List<Object> findNodeAndConvertToList(JsonNode rootNode, String nodePath) {
        JsonNode currentNode = findNode(rootNode, nodePath);
        if (currentNode.isMissingNode()) {
            return Collections.emptyList(); // Invalid path, return empty list
        }
        if (!currentNode.isArray()) {
            throw new IllegalArgumentException("The specified path does not lead to an array node");
        }
        return convertToList(currentNode);
    }

    // Helper method to find a node by path
    private static JsonNode findNode(JsonNode rootNode, String nodePath) {
        if (nodePath.equals(".")) {
            return rootNode;
        }

        String[] pathSegments = nodePath.split("\\.");
        JsonNode currentNode = rootNode;

        for (String segment : pathSegments) {
            if (segment.contains("[") && segment.endsWith("]")) {
                String nodeName = segment.substring(0, segment.indexOf('['));
                int index = Integer.parseInt(segment.substring(segment.indexOf('[') + 1, segment.indexOf(']')));
                currentNode = currentNode.path(nodeName);
                if (currentNode.isArray()) {
                    currentNode = currentNode.get(index);
                } else {
                    return JsonNodeFactory.instance.missingNode(); // Invalid path, return missing node
                }
            } else {
                currentNode = currentNode.path(segment);
            }

            if (currentNode.isMissingNode()) {
                return JsonNodeFactory.instance.missingNode(); // Invalid path, return missing node
            }
        }

        return currentNode;
    }
}
